import [print, println, sleep, clearScreen] from "atom:std";
import [cos, sin, floor, max] from "atom:math";
import [len] from "atom:string";
import [exec] from "atom:os";
import "atom:number";

const PI = 3.141592653589793;

// Make the donut bigger and more visible
const width = 80;
const height = 24;
const R1 = 1.2;   // Inner radius (tube)
const R2 = 3.0;   // Outer radius (distance from center)
const K1 = 32;    // Horizontal scaling factor
const K2 = 12;    // Vertical scaling factor
const Kz = 8;     // Z scaling for perspective

var screen = [];
var zbuffer = [];

func initBuffers() {
    screen = [];
    zbuffer = [];
    for (local i = 0; i < height; i++) {
        local row = [];
        local zrow = [];
        for (local j = 0; j < width; j++) {
            row.push(" ");
            zrow.push(-1e9);
        }
        screen.push(row);
        zbuffer.push(zrow);
    }
}

func renderDonut(A, B) {
    initBuffers();

    local cosA = cos(A);
    local sinA = sin(A);
    local cosB = cos(B);
    local sinB = sin(B);

    // Use more points for smoother donut
    for (local theta = 0.0; theta < 2 * PI; theta += 0.035) {
        local costheta = cos(theta);
        local sintheta = sin(theta);

        for (local phi = 0.0; phi < 2 * PI; phi += 0.015) {
            local cosphi = cos(phi);
            local sinphi = sin(phi);

            // 3D coordinates before rotation
            local circlex = R2 + R1 * costheta;
            local circley = R1 * sintheta;

            // 3D rotation
            local x = circlex * (cosB * cosphi + sinA * sinB * sinphi) - circley * cosA * sinB;
            local y = circlex * (sinB * cosphi - sinA * cosB * sinphi) + circley * cosA * cosB;
            local z = cosA * circlex * sinphi + sinA * circley;

            // Perspective projection
            local ooz = 1 / (z + Kz);
            local xp = floor(width / 2 + K1 * ooz * x);
            local yp = floor(height / 2 - K2 * ooz * y);

            // Luminance calculation (surface normal dot light direction)
            local L = cosphi * costheta * sinB - cosA * costheta * sinphi - sinA * sintheta + cosB * (cosA * sintheta - costheta * sinphi * sinA);

            if (L > 0) {
                if (xp >= 0 && xp < width && yp >= 0 && yp < height) {
                    if (ooz > zbuffer[yp][xp]) {
                        zbuffer[yp][xp] = ooz;
                        // More visible luminance ramp
                        local chars = " .,-~:;=!*#$@";
                        local luminance = floor(L * 8.5);
                        if (luminance < 0) luminance = 0;
                        if (luminance >= len(chars)) luminance = len(chars) - 1;
                        screen[yp][xp] = chars[luminance];
                    }
                }
            }
        }
    }

    // Clear screen (if available)
    if (typeof(clearScreen) == "function") {
        clearScreen();
    } else {
        // Fallback: print newlines
        for (local i = 0; i < 4; i++) println("");
    }

    // Print the result
    for (local i = 0; i < height; i++) {
        local line = "";
        for (local j = 0; j < width; j++) {
            line += screen[i][j];
        }
        println(line);
    }
}

// Animation loop
var A = 0.0;
var B = 0.0;
const frames = number.parseInt(std.readLine("Doughnut Frames>")) catch (err) {
    return 1;
};
for (local frame = 0; frame < frames; frame++) {
    renderDonut(A, B);
    A += 0.07; // Faster rotation for more visible animation
    B += 0.03;
}
println("Done with ", frames, " frames");
