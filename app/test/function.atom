import [print, println, throw] from "atom:std";

// Basic function tests
func test_basic_functions() {
    println("=== Basic Function Tests ===");
    
    local add = func(a, b) {
        return a + b;
    };
    
    local multiply = func(x, y) {
        return x * y;
    };
    
    local greet = func(name) {
        return "Hello, " + name + "!";
    };
    
    local result1 = add(5, 3);
    if (result1 != 8) {
        throw("add(5, 3) expected 8 but got " + result1);
    }
    println("add(5, 3) =", result1);
    
    local result2 = multiply(4, 7);
    if (result2 != 28) {
        throw("multiply(4, 7) expected 28 but got " + result2);
    }
    println("multiply(4, 7) =", result2);
    
    local result3 = greet("World");
    if (result3 != "Hello, World!") {
        throw("greet('World') expected 'Hello, World!' but got '" + result3 + "'");
    }
    println("greet('World') =", result3);
}

// Function with local variables
func test_local_variables() {
    println("=== Local Variables Tests ===");
    
    local calculateArea = func(radius) {
        const pi = 3.14159;
        local area = pi * radius * radius;
        return area;
    };
    
    local fibonacci = func(n) {
        if (n <= 1) {
            return n;
        }
        local a = 0;
        local b = 1;
        local temp;
        
        for (local i = 2; i <= n; i += 1) {
            temp = a + b;
            a = b;
            b = temp;
        }
        return b;
    };
    
    local area = calculateArea(5);
    local expectedArea = 78.53975; // 3.14159 * 5 * 5
    if (area < expectedArea - 0.001 || area > expectedArea + 0.001) {
        throw("Circle area (radius 5) expected approximately " + expectedArea + " but got " + area);
    }
    println("Circle area (radius 5):", area);
    
    local fib10 = fibonacci(10);
    if (fib10 != 55) {
        throw("Fibonacci(10) expected 55 but got " + fib10);
    }
    println("Fibonacci(10):", fib10);
    
    local fib15 = fibonacci(15);
    if (fib15 != 610) {
        throw("Fibonacci(15) expected 610 but got " + fib15);
    }
    println("Fibonacci(15):", fib15);
}

// Recursive functions
func test_recursive_functions() {
    println("=== Recursive Function Tests ===");
    
    local factorial = null;
    factorial = func(n) {
        if (n <= 1) {
            return 1;
        }
        return n * factorial(n - 1);
    };
    
    local power = null;
    power = func(base, exp) {
        if (exp == 0) {
            return 1;
        }
        if (exp == 1) {
            return base;
        }
        return base * power(base, exp - 1);
    };
    
    local gcd = null;
    gcd = func(a, b) {
        if (b == 0) {
            return a;
        }
        return gcd(b, a % b);
    };
    
    local fact5 = factorial(5);
    if (fact5 != 120) {
        throw("factorial(5) expected 120 but got " + fact5);
    }
    println("factorial(5) =", fact5);
    
    local fact7 = factorial(7);
    if (fact7 != 5040) {
        throw("factorial(7) expected 5040 but got " + fact7);
    }
    println("factorial(7) =", fact7);
    
    local pow28 = power(2, 8);
    if (pow28 != 256) {
        throw("power(2, 8) expected 256 but got " + pow28);
    }
    println("power(2, 8) =", pow28);
    
    local pow34 = power(3, 4);
    if (pow34 != 81) {
        throw("power(3, 4) expected 81 but got " + pow34);
    }
    println("power(3, 4) =", pow34);
    
    local gcd1 = gcd(48, 18);
    if (gcd1 != 6) {
        throw("gcd(48, 18) expected 6 but got " + gcd1);
    }
    println("gcd(48, 18) =", gcd1);
    
    local gcd2 = gcd(100, 25);
    if (gcd2 != 25) {
        throw("gcd(100, 25) expected 25 but got " + gcd2);
    }
    println("gcd(100, 25) =", gcd2);
}

// Higher-order functions
func test_higher_order_functions() {
    println("=== Higher-Order Function Tests ===");
    
    local applyOperation = func(a, b, operation) {
        return operation(a, b);
    };
    
    local add = func(x, y) {
        return x + y;
    };
    
    local subtract = func(x, y) {
        return x - y;
    };
    
    local multiply = func(x, y) {
        return x * y;
    };
    
    local result1 = applyOperation(10, 5, add);
    if (result1 != 15) {
        throw("applyOperation(10, 5, add) expected 15 but got " + result1);
    }
    println("applyOperation(10, 5, add) =", result1);
    
    local result2 = applyOperation(10, 5, subtract);
    if (result2 != 5) {
        throw("applyOperation(10, 5, subtract) expected 5 but got " + result2);
    }
    println("applyOperation(10, 5, subtract) =", result2);
    
    local result3 = applyOperation(10, 5, multiply);
    if (result3 != 50) {
        throw("applyOperation(10, 5, multiply) expected 50 but got " + result3);
    }
    println("applyOperation(10, 5, multiply) =", result3);
    
    // Function that returns a function
    local createMultiplier = func(factor) {
        return func(x) {
            return x * factor;
        };
    };
    
    const double = createMultiplier(2);
    const triple = createMultiplier(3);
    
    local double7 = double(7);
    if (double7 != 14) {
        throw("double(7) expected 14 but got " + double7);
    }
    println("double(7) =", double7);
    
    local triple7 = triple(7);
    if (triple7 != 21) {
        throw("triple(7) expected 21 but got " + triple7);
    }
    println("triple(7) =", triple7);
}

// Closure tests
func test_closures() {
    println("=== Closure Tests ===");
    
    local createCounter = func(start) {
        local count = start;
        return func() {
            count += 1;
            return count;
        };
    };
    
    const counter1 = createCounter(0);
    const counter2 = createCounter(100);
    
    local c1_1 = counter1();
    if (c1_1 != 1) {
        throw("counter1() first call expected 1 but got " + c1_1);
    }
    println("counter1():", c1_1);
    
    local c1_2 = counter1();
    if (c1_2 != 2) {
        throw("counter1() second call expected 2 but got " + c1_2);
    }
    println("counter1():", c1_2);
    
    local c2_1 = counter2();
    if (c2_1 != 101) {
        throw("counter2() first call expected 101 but got " + c2_1);
    }
    println("counter2():", c2_1);
    
    local c1_3 = counter1();
    if (c1_3 != 3) {
        throw("counter1() third call expected 3 but got " + c1_3);
    }
    println("counter1():", c1_3);
    
    local c2_2 = counter2();
    if (c2_2 != 102) {
        throw("counter2() second call expected 102 but got " + c2_2);
    }
    println("counter2():", c2_2);
    
    // Closure with multiple functions
    local createCalculator = func(initial) {
        local value = initial;
        
        return {
            add: func(x) {
                value += x;
                return value;
            },
            subtract: func(x) {
                value -= x;
                return value;
            },
            getValue: func() {
                return value;
            }
        };
    };
    
    const calc = createCalculator(10);
    
    local addResult = calc.add(5);
    if (addResult != 15) {
        throw("calc.add(5) expected 15 but got " + addResult);
    }
    println("calc.add(5):", addResult);
    
    local subtractResult = calc.subtract(3);
    if (subtractResult != 12) {
        throw("calc.subtract(3) expected 12 but got " + subtractResult);
    }
    println("calc.subtract(3):", subtractResult);
    
    local getValue = calc.getValue();
    if (getValue != 12) {
        throw("calc.getValue() expected 12 but got " + getValue);
    }
    println("calc.getValue():", getValue);
}

// Pascal's triangle implementation
func pascal(n) {
    const triangle = [];
    
    for (local i = 0; i < n; i += 1) {
        const row = [];
        
        for (local j = 0; j <= i; j += 1) {
            if (j == 0 || j == i) {
                row.push(1);
            } else {
                const prevRow = triangle[i - 1];
                row.push(prevRow[j - 1] + prevRow[j]);
            }
        }
        
        triangle.push(row);
    }
    
    return triangle;
}

func printPascalTriangle(n) {
    const triangle = pascal(n);
    
    for (local i = 0; i < triangle.length(); i += 1) {
        const row = triangle[i];
        local line = "";
        
        // Add spacing for alignment
        for (local k = 0; k < n - i - 1; k += 1) {
            line += " ";
        }
        
        // Add numbers with spacing
        for (local j = 0; j < row.length(); j += 1) {
            line += row[j];
            if (j < row.length() - 1) {
                line += " ";
            }
        }
        
        println(line);
    }
}

func test_pascal_triangle() {
    println("=== Pascal Triangle Tests ===");
    println("Pascal's triangle with 6 rows:");
    printPascalTriangle(6);
    
    println("\nPascal's triangle with 8 rows:");
    printPascalTriangle(8);
    
    // Test individual triangle generation
    const triangle5 = pascal(5);
    if (triangle5.length() != 5) {
        throw("Pascal triangle with 5 rows should have 5 rows but got " + triangle5.length());
    }
    
    // Check first row
    if (triangle5[0].length() != 1 || triangle5[0][0] != 1) {
        throw("Pascal triangle row 0 should be [1] but got " + triangle5[0]);
    }
    
    // Check last row
    const lastRow = triangle5[4];
    if (lastRow.length() != 5 || lastRow[0] != 1 || lastRow[1] != 4 || lastRow[2] != 6 || lastRow[3] != 4 || lastRow[4] != 1) {
        throw("Pascal triangle row 4 should be [1,4,6,4,1] but got " + lastRow);
    }
    
    println("\nTriangle array for 5 rows:", triangle5);
}

// Function parameter variations
func test_function_parameters() {
    println("=== Function Parameter Tests ===");
    
    local noParams = func() {
        return "No parameters";
    };
    
    local oneParam = func(x) {
        return "One parameter: " + x;
    };
    
    local multipleParams = func(a, b, c, d) {
        return "Sum: " + (a + b + c + d);
    };
    
    local mixedTypes = func(num, str, bool, arr) {
        return "Mixed: " + num + ", " + str + ", " + bool + ", " + arr.length();
    };
    
    local result1 = noParams();
    if (result1 != "No parameters") {
        throw("noParams() expected 'No parameters' but got '" + result1 + "'");
    }
    println("noParams():", result1);
    
    local result2 = oneParam(42);
    if (result2 != "One parameter: 42") {
        throw("oneParam(42) expected 'One parameter: 42' but got '" + result2 + "'");
    }
    println("oneParam(42):", result2);
    
    local result3 = multipleParams(1, 2, 3, 4);
    if (result3 != "Sum: 10") {
        throw("multipleParams(1, 2, 3, 4) expected 'Sum: 10' but got '" + result3 + "'");
    }
    println("multipleParams(1, 2, 3, 4):", result3);
    
    local result4 = mixedTypes(10, "hello", true, [1, 2, 3]);
    if (result4 != "Mixed: 10, hello, true, 3") {
        throw("mixedTypes expected 'Mixed: 10, hello, true, 3' but got '" + result4 + "'");
    }
    println("mixedTypes(10, 'hello', true, [1,2,3]):", result4);
}

// Function stress tests
func test_function_stress() {
    println("=== Function Stress Tests ===");
    
    // Deep recursion test
    local deepRecursion = null;
    deepRecursion = func(n, acc) {
        if (n <= 0) {
            return acc;
        }
        return deepRecursion(n - 1, acc + n);
    };
    
    local deepResult = deepRecursion(100, 0);
    local expected = 5050; // Sum of 1 to 100
    if (deepResult != expected) {
        throw("Deep recursion (sum 1-100) expected " + expected + " but got " + deepResult);
    }
    println("Deep recursion (sum 1-100):", deepResult);
    
    // Many function calls
    local simpleAdd = func(a, b) {
        return a + b;
    };
    
    local total = 0;
    for (local i = 0; i < 1000; i += 1) {
        total = simpleAdd(total, i);
    }
    local expectedTotal = 499500; // Sum of 0 to 999
    if (total != expectedTotal) {
        throw("1000 function calls result expected " + expectedTotal + " but got " + total);
    }
    println("1000 function calls result:", total);
    
    // Nested function definitions
    local outerFunction = func(x) {
        local innerFunction1 = func(y) {
            local innerFunction2 = func(z) {
                return x + y + z;
            };
            return innerFunction2(y * 2);
        };
        return innerFunction1(x + 1);
    };
    
    local nestedResult = outerFunction(5);
    local expectedNested = 5 + 6 + 12; // x=5, y=6, z=12
    if (nestedResult != expectedNested) {
        throw("Nested functions result expected " + expectedNested + " but got " + nestedResult);
    }
    println("Nested functions result:", nestedResult);
    
    // Function array operations
    const operations = [
        func(x) { return x + 1; },
        func(x) { return x * 2; },
        func(x) { return x - 3; },
        func(x) { return x / 2; }
    ];
    
    local value = 10;
    const expectedValues = [11, 22, 19, 9.5];
    for (local i = 0; i < operations.length(); i += 1) {
        value = operations[i](value);
        if (value != expectedValues[i]) {
            throw("After operation " + i + " expected " + expectedValues[i] + " but got " + value);
        }
        println("After operation", i, "value:", value);
    }
}

// Complex mathematical functions
func test_complex_math_functions() {
    println("=== Complex Math Function Tests ===");
    
    local isPrime = func(n) {
        if (n < 2) return false;
        if (n == 2) return true;
        if (n % 2 == 0) return false;
        
        for (local i = 3; i * i <= n; i += 2) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    };
    
    local findPrimes = func(limit) {
        const primes = [];
        for (local i = 2; i <= limit; i += 1) {
            if (isPrime(i)) {
                primes.push(i);
            }
        }
        return primes;
    };
    
    const primes = findPrimes(50);
    const expectedPrimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47];
    if (primes.length() != expectedPrimes.length()) {
        throw("Expected " + expectedPrimes.length() + " primes up to 50 but got " + primes.length());
    }
    for (local i = 0; i < expectedPrimes.length(); i += 1) {
        if (primes[i] != expectedPrimes[i]) {
            throw("Prime at index " + i + " expected " + expectedPrimes[i] + " but got " + primes[i]);
        }
    }
    println("Primes up to 50:", primes);

    local quickSort = null;
    quickSort = func(arr) {
        if (arr.length() <= 1) {
            return arr;
        }
        
        const pivot = arr[0];
        const less = [];
        const greater = [];
        
        for (local i = 1; i < arr.length(); i += 1) {
            if (arr[i] <= pivot) {
                less.push(arr[i]);
            } else {
                greater.push(arr[i]);
            }
        }
        
        const sortedLess = quickSort(less);
        const sortedGreater = quickSort(greater);
        
        const result = [];
        for (local i = 0; i < sortedLess.length(); i += 1) {
            result.push(sortedLess[i]);
        }
        result.push(pivot);
        for (local i = 0; i < sortedGreater.length(); i += 1) {
            result.push(sortedGreater[i]);
        }
        
        return result;
    };
    
    const unsorted = [64, 34, 25, 12, 22, 11, 90, 88, 76, 50, 42];
    println("Unsorted array:", unsorted);
    const sorted = quickSort(unsorted);
    const expectedSorted = [11, 12, 22, 25, 34, 42, 50, 64, 76, 88, 90];
    
    if (sorted.length() != expectedSorted.length()) {
        throw("Sorted array length expected " + expectedSorted.length() + " but got " + sorted.length());
    }
    for (local i = 0; i < expectedSorted.length(); i += 1) {
        if (sorted[i] != expectedSorted[i]) {
            throw("Sorted array at index " + i + " expected " + expectedSorted[i] + " but got " + sorted[i]);
        }
    }
    println("Sorted array:", sorted);
}

// Function edge cases
func test_function_edge_cases() {
    println("=== Function Edge Cases Tests ===");
    
    // Function returning function returning function
    local createChain = func() {
        return func() {
            return func() {
                return "Deep chain result";
            };
        };
    };
    
    const chain = createChain();
    const result = chain()();
    if (result != "Deep chain result") {
        throw("Function chain result expected 'Deep chain result' but got '" + result + "'");
    }
    println("Function chain result:", result);
    
    // Function with complex closure capture
    local createComplexClosure = func() {
        const data = [1, 2, 3, 4, 5];
        local multiplier = 2;
        
        return func(index) {
            multiplier += 1;
            return data[index] * multiplier;
        };
    };
    
    const complexFunc = createComplexClosure();
    println("Complex closure results:");
    const expectedResults = [3, 8, 15, 24, 35]; // data[i] * (3+i)
    for (local i = 0; i < 5; i += 1) {
        local result = complexFunc(i);
        if (result != expectedResults[i]) {
            throw("Complex closure at index " + i + " expected " + expectedResults[i] + " but got " + result);
        }
        println("  Index", i, ":", result);
    }

    local isOdd = null;
    local isEven = null;
    
    // Mutual recursion
    isEven = func(n) {
        if (n == 0) return true;
        return isOdd(n - 1);
    };
    
    isOdd = func(n) {
        if (n == 0) return false;
        return isEven(n - 1);
    };
    
    local even10 = isEven(10);
    if (even10 != true) {
        throw("isEven(10) expected true but got " + even10);
    }
    println("isEven(10):", even10);
    
    local odd10 = isOdd(10);
    if (odd10 != false) {
        throw("isOdd(10) expected false but got " + odd10);
    }
    println("isOdd(10):", odd10);
    
    local even15 = isEven(15);
    if (even15 != false) {
        throw("isEven(15) expected false but got " + even15);
    }
    println("isEven(15):", even15);
    
    local odd15 = isOdd(15);
    if (odd15 != true) {
        throw("isOdd(15) expected true but got " + odd15);
    }
    println("isOdd(15):", odd15);
}

// Run all tests
func run_all_function_tests() {
    test_basic_functions();
    test_local_variables();
    test_recursive_functions();
    test_higher_order_functions();
    test_closures();
    test_pascal_triangle();
    test_function_parameters();
    test_function_stress();
    test_complex_math_functions();
    test_function_edge_cases();
    println("=== All Function Tests Complete ===");
}

run_all_function_tests();
