import [ println, throw ] from "atom:std";

println("=== Class Stress Test ===");

// Test 1: Basic class functionality
class Animal {
    func init(self, name, species) {
        if (name == null || species == null) {
            throw("Animal constructor requires name and species");
        }
        self.name = name;
        self.species = species;
        println("Created animal:", name, "(" + species + ")");
    }

    func speak(self) {
        if (self.name == null) {
            throw("Animal name is null, cannot speak");
        }
        println(self.name, "makes a sound");
    }

    func getInfo(self) {
        if (self.name == null || self.species == null) {
            throw("Animal missing required properties for getInfo");
        }
        return self.name + " is a " + self.species;
    }
}

class Dog {
    func init(self, name, breed) {
        if (name == null || breed == null) {
            throw("Dog constructor requires name and breed");
        }
        println("Dog", name, breed);
        self.name = name;
        self.breed = breed;
        self.species = "dog";
        println("Created dog:", name, "(" + breed + ")");
    }

    func speak(self) {
        if (self.name == null) {
            throw("Dog name is null, cannot speak");
        }
        println(self.name, "barks: Woof!");
    }

    func wagTail(self) {
        if (self.name == null) {
            throw("Dog name is null, cannot wag tail");
        }
        println(self.name, "wags tail happily");
    }

    func getInfo(self) {
        if (self.name == null || self.breed == null || self.species == null) {
            throw("Dog missing required properties for getInfo");
        }
        return self.name + " is a " + self.breed + " " + self.species;
    }
}

class Cat {
    func init(self, name, color) {
        if (name == null || color == null) {
            throw("Cat constructor requires name and color");
        }
        self.name = name;
        self.color = color;
        self.species = "cat";
        println("Created cat:", name, "(" + color + ")");
    }

    func speak(self) {
        if (self.name == null) {
            throw("Cat name is null, cannot speak");
        }
        println(self.name, "meows: Meow!");
    }

    func purr(self) {
        if (self.name == null) {
            throw("Cat name is null, cannot purr");
        }
        println(self.name, "purrs contentedly");
    }

    func getInfo(self) {
        if (self.name == null || self.color == null || self.species == null) {
            throw("Cat missing required properties for getInfo");
        }
        return self.name + " is a " + self.color + " " + self.species;
    }
}

println("\n--- Basic Class Test ---");
const dog1 = new Dog("Buddy", "Golden Retriever");
const cat1 = new Cat("Whiskers", "orange");
const animal1 = new Animal("Generic", "unknown");

dog1.speak();
dog1.wagTail();
cat1.speak();
cat1.purr();
animal1.speak();

println("Dog info:", dog1.getInfo());
println("Cat info:", cat1.getInfo());
println("Animal info:", animal1.getInfo());

// Test 2: Static methods and properties
class MathUtils {
    func init(self) {
        println("MathUtils instance created");
    }

    func add(a, b) {
        if (a == null || b == null) {
            throw("MathUtils.add requires two non-null arguments");
        }
        return a + b;
    }

    func multiply(a, b) {
        if (a == null || b == null) {
            throw("MathUtils.multiply requires two non-null arguments");
        }
        return a * b;
    }

    func factorial(n) {
        if (n == null || n < 0) {
            throw("MathUtils.factorial requires non-negative number");
        }
        if (n <= 1) {
            return 1;
        }
        return n * MathUtils.factorial(n - 1);
    }
}

println("\n--- Static Methods Test ---");
println("5 + 3 =", MathUtils.add(5, 3));
println("4 * 7 =", MathUtils.multiply(4, 7));
println("5! =", MathUtils.factorial(5));

// Test 3: Polymorphism without inheritance
println("\n--- Polymorphism Test ---");
const animals = [
    new Dog("Rex", "German Shepherd"),
    new Cat("Luna", "black"),
    new Animal("Generic", "unknown")
];

var i = 0;
while (i < animals.length()) {
    if (animals[i] == null) {
        throw("Null animal found in array at index " + i);
    }
    animals[i].speak();
    i = i + 1;
}

// Test 4: Complex class with multiple methods
class BankAccount {
    func init(self, owner, initialBalance) {
        if (owner == null || initialBalance == null || initialBalance < 0) {
            throw("BankAccount requires valid owner and non-negative initial balance");
        }
        self.owner = owner;
        self.balance = initialBalance;
        self.transactions = [];
        println("Account created for", owner, "with balance:", initialBalance);
    }

    func deposit(self, amount) {
        if (amount == null || amount <= 0) {
            throw("Deposit amount must be positive");
        }
        self.balance = self.balance + amount;
        self.transactions.push("Deposit: +" + amount);
        println("Deposited", amount, "New balance:", self.balance);
    }

    func withdraw(self, amount) {
        if (amount == null || amount <= 0) {
            throw("Withdrawal amount must be positive");
        }
        if (self.balance >= amount) {
            self.balance = self.balance - amount;
            self.transactions.push("Withdrawal: -" + amount);
            println("Withdrew", amount, "New balance:", self.balance);
            return true;
        } else {
            println("Insufficient funds for withdrawal of", amount);
            return false;
        }
    }

    func getBalance(self) {
        return self.balance;
    }

    func getTransactionHistory(self) {
        if (self.owner == null || self.transactions == null) {
            throw("Account data corrupted, cannot get transaction history");
        }
        println("Transaction history for", self.owner + ":");
        local i = 0;
        while (i < self.transactions.length()) {
            println("-", self.transactions[i]);
            i = i + 1;
        }
    }
}

class SavingsAccount {
    func init(self, owner, initialBalance, interestRate) {
        if (owner == null || initialBalance == null || interestRate == null || initialBalance < 0 || interestRate < 0) {
            throw("SavingsAccount requires valid owner, non-negative balance and interest rate");
        }
        self.owner = owner;
        self.balance = initialBalance;
        self.interestRate = interestRate;
        self.transactions = [];
        println("Savings account created for", owner, "with balance:", initialBalance, "and rate:", interestRate);
    }

    func deposit(self, amount) {
        if (amount == null || amount <= 0) {
            throw("Deposit amount must be positive");
        }
        self.balance = self.balance + amount;
        self.transactions.push("Deposit: +" + amount);
        println("Deposited", amount, "New balance:", self.balance);
    }

    func withdraw(self, amount) {
        if (amount == null || amount <= 0) {
            throw("Withdrawal amount must be positive");
        }
        if (self.balance >= amount) {
            self.balance = self.balance - amount;
            self.transactions.push("Withdrawal: -" + amount);
            println("Withdrew", amount, "New balance:", self.balance);
            return true;
        } else {
            println("Insufficient funds for withdrawal of", amount);
            return false;
        }
    }

    func addInterest(self) {
        if (self.balance == null || self.interestRate == null) {
            throw("Account data corrupted, cannot add interest");
        }
        const interest = self.balance * self.interestRate;
        self.balance = self.balance + interest;
        self.transactions.push("Interest: +" + interest);
        println("Added interest:", interest, "New balance:", self.balance);
    }

    func getBalance(self) {
        return self.balance;
    }

    func getTransactionHistory(self) {
        if (self.owner == null || self.transactions == null) {
            throw("Account data corrupted, cannot get transaction history");
        }
        println("Transaction history for", self.owner + ":");
        local i = 0;
        while (i < self.transactions.length()) {
            println("-", self.transactions[i]);
            i = i + 1;
        }
    }
}

println("\n--- Banking System Test ---");
const account1 = new BankAccount("Alice", 1000);
const savings1 = new SavingsAccount("Bob", 5000, 0.05);

account1.deposit(500);
account1.withdraw(200);
account1.withdraw(2000); // Should fail

savings1.deposit(1000);
savings1.addInterest();
savings1.withdraw(500);

account1.getTransactionHistory();
savings1.getTransactionHistory();

// Test 5: Stress test with many instances
println("\n--- Mass Instance Creation Test ---");
const manyDogs = [];
var j = 0;
while (j < 50) {
    const dogName = "Dog" + j;
    const breeds = ["Labrador", "Poodle", "Bulldog", "Beagle", "Husky"];
    if (breeds.length() == 0) {
        throw("Breeds array is empty");
    }
    const breed = breeds[j % breeds.length()];
    manyDogs.push(new Dog(dogName, breed));
    j = j + 1;
}

if (manyDogs.length() != 50) {
    throw("Expected 50 dogs but created " + manyDogs.length());
}

println("Created", manyDogs.length(), "dogs");
println("First dog:", manyDogs[0].name, manyDogs[0].breed);
println("Last dog:", manyDogs[49].name, manyDogs[49].breed);

// Test 6: Method chaining
class FluentBuilder {
    func init(self) {
        self.data = {};
    }

    func setName(self, name) {
        if (name == null) {
            throw("Name cannot be null");
        }
        self.data.name = name;
        return self;
    }

    func setAge(self, age) {
        if (age == null || age < 0) {
            throw("Age must be non-negative");
        }
        self.data.age = age;
        return self;
    }

    func setCity(self, city) {
        if (city == null) {
            throw("City cannot be null");
        }
        self.data.city = city;
        return self;
    }

    func build(self) {
        if (self.data == null) {
            throw("Builder data is corrupted");
        }
        return self.data;
    }
}

println("\n--- Method Chaining Test ---");
const builder = new FluentBuilder();
const result = builder.setName("John").setAge(30).setCity("New York").build();
if (result.name != "John" || result.age != 30 || result.city != "New York") {
    throw("Method chaining produced incorrect result");
}
println("Built object:", result.name, result.age, result.city);

// Test 7: Class with closures
class Counter {
    func init(self, start) {
        if (start == null) {
            throw("Counter start value cannot be null");
        }
        self.value = start;
    }

    func getIncrementer(self) {
        return func() {
            self.value = self.value + 1;
            return self.value;
        };
    }

    func getDecrementer(self) {
        return func() {
            self.value = self.value - 1;
            return self.value;
        };
    }

    func getValue(self) {
        return self.value;
    }
}

println("\n--- Class with Closures Test ---");
const counter = new Counter(10);
const inc = counter.getIncrementer();
const dec = counter.getDecrementer();

if (counter.getValue() != 10) {
    throw("Counter initial value is incorrect");
}

println("Initial value:", counter.getValue());
const incResult1 = inc();
if (incResult1 != 11) {
    throw("First increment returned " + incResult1 + " instead of 11");
}
println("After increment:", incResult1);

const incResult2 = inc();
if (incResult2 != 12) {
    throw("Second increment returned " + incResult2 + " instead of 12");
}
println("After increment:", incResult2);

const decResult = dec();
if (decResult != 11) {
    throw("Decrement returned " + decResult + " instead of 11");
}
println("After decrement:", decResult);

if (counter.getValue() != 11) {
    throw("Final counter value is " + counter.getValue() + " instead of 11");
}
println("Final value:", counter.getValue());

// Test 8: Class with dynamic properties
class DynamicObject {
    func init(self) {
        self.properties = {};
    }

    func set(self, key, value) {
        if (key == null) {
            throw("Property key cannot be null");
        }
        self.properties[key] = value;
        println("Set", key, "to", value);
    }

    func get(self, key) {
        if (key == null) {
            throw("Property key cannot be null");
        }
        if (self.properties[key] != null) {
            return self.properties[key];
        } else {
            println("Property", key, "not found");
            return null;
        }
    }

    func listProperties(self) {
        if (self.properties == null) {
            throw("Properties object is null");
        }
        println("Properties:");
        // Note: would need object iteration support to fully implement this
        println("- properties object exists");
    }
}

println("\n--- Dynamic Properties Test ---");
const dynObj = new DynamicObject();
dynObj.set("name", "Dynamic");
dynObj.set("value", 42);

const nameResult = dynObj.get("name");
if (nameResult != "Dynamic") {
    throw("Expected 'Dynamic' but got " + nameResult);
}
println("Name:", nameResult);

const valueResult = dynObj.get("value");
if (valueResult != 42) {
    throw("Expected 42 but got " + valueResult);
}
println("Value:", valueResult);

const missingResult = dynObj.get("missing");
if (missingResult != null) {
    throw("Expected null for missing property but got " + missingResult);
}
println("Missing:", missingResult);

// Test 9: Class method assignment
class Vehicle {
    func init(self, type) {
        if (type == null) {
            throw("Vehicle type cannot be null");
        }
        self.type = type;
    }

    func start(self) {
        if (self.type == null) {
            throw("Vehicle type is null, cannot start");
        }
        println(self.type, "is starting");
    }

    func stop(self) {
        if (self.type == null) {
            throw("Vehicle type is null, cannot stop");
        }
        println(self.type, "is stopping");
    }
}

println("\n--- Method Assignment Test ---");
const car = new Vehicle("Car");
const bike = new Vehicle("Bike");

// Assign methods to variables
const startCar = car.start;
const stopBike = bike.stop;

car.start();
bike.start();
car.stop();
bike.stop();

println("\n=== Class Stress Test Complete ===");

class T {
    func init(self, a, b) {
        if (a == null || b == null) {
            throw("T constructor requires non-null a and b values");
        }
        self.a = a;
        self.b = b;
    }

    func add(self) {
        if (self.a == null || self.b == null) {
            throw("T instance has null values, cannot add");
        }
        return self.a + self.b;
    }
}

const t = new T(1, 2);
const a = [1,2,3];

T.add = a.push;

t.add(4);
if (a.length() != 4 || a[3] != 4) {
    throw("Method reassignment test failed - array should contain [1,2,3,4]");
}
println(a); // [1,2,3,4]


// Base Test

class A {
    func init(self) {
        println("A init");
        self.other = "Other";
    }

    func getProp(self) {
        return self.prop;
    } 

    func override(self) {
        return "A override";
    }
}

class B extends A {

    func init(self, prop) {
        base.init(self);
        self.prop = prop;
    }

    func override(self) {
        // return "B override";
        return base.override(self);
    }

}

const b = new B("Property");
println(b, b.getProp(), b.override(), typeof(b));