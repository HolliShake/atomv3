import [println] from "atom:std";

// Variable scoping in loops stress test
println("\n=== VARIABLE SCOPING IN LOOPS STRESS TEST ===");

// Test 1: Local variables in for loop don't leak outside
var outsideVar = "outside";
for (local i = 0; i < 3; i++) {
    local insideVar = "inside_" + i;
    outsideVar += "_" + i;
}
// insideVar should not be accessible here
// i should not be accessible here
println("Outside var after for loop:", outsideVar);
if (outsideVar != "outside_0_1_2") {
    std.throw("For loop scoping test 1 failed -> " + outsideVar);
}

// Test 2: Variable shadowing in nested loops
var shadowVar = "global";
for (local i = 0; i < 2; i++) {
    local shadowVar = "outer_" + i;
    for (local j = 0; j < 2; j++) {
        local shadowVar = "inner_" + i + "_" + j;
        // innermost shadowVar should be used
    }
    // outer shadowVar should be used here
}
// global shadowVar should still be "global"
println("Shadow var after nested loops:", shadowVar);
if (shadowVar != "global") {
    std.throw("Variable shadowing test failed -> " + shadowVar);
}

// Test 3: Loop counter reuse in separate loops
var counterSum = 0;
for (local i = 0; i < 3; i++) {
    counterSum += i;
}
for (local i = 10; i < 13; i++) {
    counterSum += i;
}
println("Counter reuse sum:", counterSum);
if (counterSum != 36) { // (0+1+2) + (10+11+12) = 3 + 33 = 36
    std.throw("Counter reuse test failed, expected 36, got " + counterSum);
}

// Test 4: Variables declared before loop vs inside loop
var beforeLoop = 0;
for (local i = 0; i < 3; i++) {
    beforeLoop += i;
    local duringLoop = i * 2;
    beforeLoop += duringLoop;
}
// beforeLoop should be accessible, duringLoop should not
println("Before loop variable:", beforeLoop);
if (beforeLoop != 9) { // (0+0) + (1+2) + (2+4) = 0 + 3 + 6 = 9
    std.throw("Before/during loop scope test failed");
}

// Test 5: While loop variable scoping
var whileOutside = "start";
var whileCounter = 0;
while (whileCounter < 3) {
    local whileInside = "while_" + whileCounter;
    whileOutside += "_" + whileInside;
    whileCounter++;
}
println("While loop scoping:", whileOutside);
if (whileOutside != "start_while_0_while_1_while_2") {
    std.throw("While loop scoping test failed");
}

// Test 6: Do-while loop variable scoping
var doWhileResult = [];
var doCounter = 0;
do {
    local doLocal = doCounter * 3;
    doWhileResult.push(doLocal);
    doCounter++;
} while (doCounter < 4);
println("Do-while scoping result:", doWhileResult);
if (doWhileResult.length() != 4 || doWhileResult[3] != 9) {
    std.throw("Do-while scoping test failed");
}

// Test 7: Nested function scoping within loops
var funcScopeResult = [];
for (local i = 0; i < 3; i++) {
    local loopVar = "loop_" + i;
    
    local innerFunc = func() {
        // Should capture loopVar from enclosing scope
        return loopVar + "_func";
    };
    
    funcScopeResult.push(innerFunc());
}
println("Function scoping in loops:", funcScopeResult);
if (funcScopeResult.length() != 3) {
    std.throw("Function scoping in loops test failed");
}

// Test 8: Variable modification across loop iterations
var modifyTest = [1, 2, 3, 4, 5];
for (local i = 0; i < modifyTest.length(); i++) {
    local temp = modifyTest[i];
    modifyTest[i] = temp * 2;
    if (i > 0) {
        // Access previous iteration's result
        local prev = modifyTest[i - 1];
        modifyTest[i] += prev;
    }
}
println("Variable modification test:", modifyTest);
// Expected: [2, 6, 12, 20, 30]
if (modifyTest[0] != 2 || modifyTest[4] != 30) {
    std.throw("Variable modification test failed");
}

// Test 9: Break and continue with local variables
var breakContinueResult = [];
for (local i = 0; i < 10; i++) {
    local processed = false;
    
    if (i % 3 == 0 && i != 0) {
        local skipMsg = "skipped_" + i;
        breakContinueResult.push(skipMsg);
        continue;
    }
    
    if (i > 6) {
        local breakMsg = "break_at_" + i;
        breakContinueResult.push(breakMsg);
        break;
    }
    
    processed = true;
    if (processed) {
        breakContinueResult.push("processed_" + i);
    }
}
println("Break/continue scoping:", breakContinueResult);
if (breakContinueResult.length() < 3) {
    std.throw("Break/continue scoping test failed");
}

// Test 10: Complex nested scoping with same variable names
var complexResult = 0;
for (local x = 1; x <= 2; x++) {
    local sum = 0;
    for (local y = 1; y <= 2; y++) {
        local sum = x * y; // shadows outer sum
        for (local z = 1; z <= 2; z++) {
            local sum = x + y + z; // shadows middle sum
            complexResult += sum;
        }
        // middle sum should be x * y here
        complexResult += sum;
    }
    // outer sum should still be 0 here
    complexResult += sum;
}

println("Complex nested scoping result:", complexResult);
// Calculate expected: inner sums + middle sums + outer sums
// Inner loop sums: (1+1+1)+(1+1+2)+(1+2+1)+(1+2+2)+(2+1+1)+(2+1+2)+(2+2+1)+(2+2+2) = 3+4+4+5+4+5+5+6 = 36
// Middle sums: (1*1)+(1*2)+(2*1)+(2*2) = 1+2+2+4 = 9
// Outer sums: 0+0 = 0
// Total: 36 + 9 + 0 = 45
var expected = 45;
if (complexResult != 45) {
    std.throw("Complex nested scoping failed, expected 45, got " + complexResult);
}

println("=== ALL VARIABLE SCOPING TESTS PASSED! ===");


var g = 0;
for  (;;) {
    g++;
    if (g >= 54) break;
    println(g);
}
