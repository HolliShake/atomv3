import [ println ] from "atom:std";

println("=== Class Stress Test ===");

// Test 1: Basic class functionality
class Animal {
    func init(self, name, species) {
        
        self.name = name;
        self.species = species;
        println("Created animal:", name, "(" + species + ")");
    }

    func speak(self) {
        println(self.name, "makes a sound");
    }

    func getInfo(self) {
        return self.name + " is a " + self.species;
    }
}

class Dog {
    func init(self, name, breed) {
        println("Dog", name, breed);
        self.name = name;
        self.breed = breed;
        self.species = "dog";
        println("Created dog:", name, "(" + breed + ")");
    }

    func speak(self) {
        println(self.name, "barks: Woof!");
    }

    func wagTail(self) {
        println(self.name, "wags tail happily");
    }

    func getInfo(self) {
        return self.name + " is a " + self.breed + " " + self.species;
    }
}

class Cat {
    func init(self, name, color) {
        self.name = name;
        self.color = color;
        self.species = "cat";
        println("Created cat:", name, "(" + color + ")");
    }

    func speak(self) {
        println(self.name, "meows: Meow!");
    }

    func purr(self) {
        println(self.name, "purrs contentedly");
    }

    func getInfo(self) {
        return self.name + " is a " + self.color + " " + self.species;
    }
}

println("\n--- Basic Class Test ---");
const dog1 = new Dog("Buddy", "Golden Retriever");
const cat1 = new Cat("Whiskers", "orange");
const animal1 = new Animal("Generic", "unknown");

dog1.speak();
dog1.wagTail();
cat1.speak();
cat1.purr();
animal1.speak();

println("Dog info:", dog1.getInfo());
println("Cat info:", cat1.getInfo());
println("Animal info:", animal1.getInfo());

// Test 2: Static methods and properties
class MathUtils {
    func init(self) {
        println("MathUtils instance created");
    }

    func add(a, b) {
        return a + b;
    }

    func multiply(a, b) {
        return a * b;
    }

    func factorial(n) {
        if (n <= 1) {
            return 1;
        }
        return n * MathUtils.factorial(n - 1);
    }
}

println("\n--- Static Methods Test ---");
println("5 + 3 =", MathUtils.add(5, 3));
println("4 * 7 =", MathUtils.multiply(4, 7));
println("5! =", MathUtils.factorial(5));

// Test 3: Polymorphism without inheritance
println("\n--- Polymorphism Test ---");
const animals = [
    new Dog("Rex", "German Shepherd"),
    new Cat("Luna", "black"),
    new Animal("Generic", "unknown")
];

var i = 0;
while (i < animals.length()) {
    animals[i].speak();
    i = i + 1;
}

// Test 4: Complex class with multiple methods
class BankAccount {
    func init(self, owner, initialBalance) {
        self.owner = owner;
        self.balance = initialBalance;
        self.transactions = [];
        println("Account created for", owner, "with balance:", initialBalance);
    }

    func deposit(self, amount) {
        self.balance = self.balance + amount;
        self.transactions.push("Deposit: +" + amount);
        println("Deposited", amount, "New balance:", self.balance);
    }

    func withdraw(self, amount) {
        if (self.balance >= amount) {
            self.balance = self.balance - amount;
            self.transactions.push("Withdrawal: -" + amount);
            println("Withdrew", amount, "New balance:", self.balance);
            return true;
        } else {
            println("Insufficient funds for withdrawal of", amount);
            return false;
        }
    }

    func getBalance(self) {
        return self.balance;
    }

    func getTransactionHistory(self) {
        println("Transaction history for", self.owner + ":");
        local i = 0;
        while (i < self.transactions.length()) {
            println("-", self.transactions[i]);
            i = i + 1;
        }
    }
}

class SavingsAccount {
    func init(self, owner, initialBalance, interestRate) {
        self.owner = owner;
        self.balance = initialBalance;
        self.interestRate = interestRate;
        self.transactions = [];
        println("Savings account created for", owner, "with balance:", initialBalance, "and rate:", interestRate);
    }

    func deposit(self, amount) {
        self.balance = self.balance + amount;
        self.transactions.push("Deposit: +" + amount);
        println("Deposited", amount, "New balance:", self.balance);
    }

    func withdraw(self, amount) {
        if (self.balance >= amount) {
            self.balance = self.balance - amount;
            self.transactions.push("Withdrawal: -" + amount);
            println("Withdrew", amount, "New balance:", self.balance);
            return true;
        } else {
            println("Insufficient funds for withdrawal of", amount);
            return false;
        }
    }

    func addInterest(self) {
        const interest = self.balance * self.interestRate;
        self.balance = self.balance + interest;
        self.transactions.push("Interest: +" + interest);
        println("Added interest:", interest, "New balance:", self.balance);
    }

    func getBalance(self) {
        return self.balance;
    }

    func getTransactionHistory(self) {
        println("Transaction history for", self.owner + ":");
        local i = 0;
        while (i < self.transactions.length()) {
            println("-", self.transactions[i]);
            i = i + 1;
        }
    }
}

println("\n--- Banking System Test ---");
const account1 = new BankAccount("Alice", 1000);
const savings1 = new SavingsAccount("Bob", 5000, 0.05);

account1.deposit(500);
account1.withdraw(200);
account1.withdraw(2000); // Should fail

savings1.deposit(1000);
savings1.addInterest();
savings1.withdraw(500);

account1.getTransactionHistory();
savings1.getTransactionHistory();

// Test 5: Stress test with many instances
println("\n--- Mass Instance Creation Test ---");
const manyDogs = [];
var j = 0;
while (j < 50) {
    const dogName = "Dog" + j;
    const breeds = ["Labrador", "Poodle", "Bulldog", "Beagle", "Husky"];
    const breed = breeds[j % breeds.length()];
    manyDogs.push(new Dog(dogName, breed));
    j = j + 1;
}

println("Created", manyDogs.length(), "dogs");
println("First dog:", manyDogs[0].name, manyDogs[0].breed);
println("Last dog:", manyDogs[49].name, manyDogs[49].breed);

// Test 6: Method chaining
class FluentBuilder {
    func init(self) {
        self.data = {};
    }

    func setName(self, name) {
        self.data.name = name;
        return self;
    }

    func setAge(self, age) {
        self.data.age = age;
        return self;
    }

    func setCity(self, city) {
        self.data.city = city;
        return self;
    }

    func build(self) {
        return self.data;
    }
}

println("\n--- Method Chaining Test ---");
const builder = new FluentBuilder();
const result = builder.setName("John").setAge(30).setCity("New York").build();
println("Built object:", result.name, result.age, result.city);

// Test 7: Class with closures
class Counter {
    func init(self, start) {
        self.value = start;
    }

    func getIncrementer(self) {
        return func() {
            self.value = self.value + 1;
            return self.value;
        };
    }

    func getDecrementer(self) {
        return func() {
            self.value = self.value - 1;
            return self.value;
        };
    }

    func getValue(self) {
        return self.value;
    }
}

println("\n--- Class with Closures Test ---");
const counter = new Counter(10);
const inc = counter.getIncrementer();
const dec = counter.getDecrementer();

println("Initial value:", counter.getValue());
println("After increment:", inc());
println("After increment:", inc());
println("After decrement:", dec());
println("Final value:", counter.getValue());

// Test 8: Class with dynamic properties
class DynamicObject {
    func init(self) {
        self.properties = {};
    }

    func set(self, key, value) {
        self.properties[key] = value;
        println("Set", key, "to", value);
    }

    func get(self, key) {
        if (self.properties[key] != null) {
            return self.properties[key];
        } else {
            println("Property", key, "not found");
            return null;
        }
    }

    func listProperties(self) {
        println("Properties:");
        // Note: would need object iteration support to fully implement this
        println("- properties object exists");
    }
}

println("\n--- Dynamic Properties Test ---");
const dynObj = new DynamicObject();
dynObj.set("name", "Dynamic");
dynObj.set("value", 42);
println("Name:", dynObj.get("name"));
println("Value:", dynObj.get("value"));
println("Missing:", dynObj.get("missing"));

// Test 9: Class method assignment
class Vehicle {
    func init(self, type) {
        self.type = type;
    }

    func start(self) {
        println(self.type, "is starting");
    }

    func stop(self) {
        println(self.type, "is stopping");
    }
}

println("\n--- Method Assignment Test ---");
const car = new Vehicle("Car");
const bike = new Vehicle("Bike");

// Assign methods to variables
const startCar = car.start;
const stopBike = bike.stop;

car.start();
bike.start();
car.stop();
bike.stop();

println("\n=== Class Stress Test Complete ===");

class T {
    func init(self, a, b) {
        self.a = a;
        self.b = b;
    }

    func add(self) {
        return self.a + self.b;
    }
}

const t = new T(1, 2);
const a = [1,2,3];

T.add = a.push;

t.add(4);
println(a); // [1,2,3,4]